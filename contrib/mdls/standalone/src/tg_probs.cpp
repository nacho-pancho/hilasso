
#include <gsl/gsl_sf_erf.h>
#include <iostream>
#include <iomanip>
#include <math.h>


#ifdef STANDALONE
#define SLOW
#endif

#include "tg_probs.h"
using namespace std;

#define erfc gsl_sf_erfc
#define erf  gsl_sf_erf


double discrete_gaussian_P(int x, double sigma)
 {
	 double xd = (double)x;
	 double g0, g1;
	 if ( x < 0 ) {
		 g0 = gsl_cdf_gaussian_P(xd-0.5, sigma);
		 g1 = gsl_cdf_gaussian_P(xd+0.5, sigma);
	 }
	 else {
		 g1 = gsl_cdf_gaussian_Q(xd-0.5, sigma);
		 g0 = gsl_cdf_gaussian_Q(xd+0.5, sigma);
	 }
	 return g1-g0;
}

double TSGD_P(int x, double theta, double d=0.0)
{

	double xr = fabs(x+d);
	double ltheta = log(theta);

	double C = (1.-theta)/(exp(d*ltheta)+exp((1.-d)*ltheta));

	return C*exp(ltheta*xr);
}

#ifdef SLOW
#define ABSIZE 256
double TSGD_Gauss_P(int z, double theta, double d, double sigma)
{
	int x;
	double p = 0.0;

	for ( x=-(ABSIZE-1); x<ABSIZE; x++ ) {
		p += TSGD_P(x, theta, d)*discrete_gaussian_P(z-x, sigma);
	}
	return p;
}

#endif


// probability density function for TSGD+Gauss
double tsgd_gauss_density(double z, double theta, double d, double sigma) {
	// generated by Maple--still needa work for stability
	// not being used currently
	double cg1 =
      log(0.1e1 / theta) * erfc(-(d + z + sigma * sigma * log(theta)) /
	  sigma * sqrt(0.2e1) / 0.2e1) * exp(log(theta) * (z + d) + sigma * sigma *
	  pow(log(theta), 0.2e1) / 0.2e1) / 0.4e1 + log(0.1e1 / theta) *
	  erfc((d + z - sigma * sigma * log(theta)) / sigma * sqrt(0.2e1) / 0.2e1) *
	  exp(-log(theta) * (z + d) + sigma * sigma * pow(log(theta), 0.2e1) / 0.2e1) / 0.4e1;

	return cg1;
}


// cumulative probability function for TSGD+Gauss
double tsgd_gauss_cumul(double z, double theta, double d, double sigma)
{
     // from Maple, with some modifications for numerical stability

	 double res,  A1, A2, A, B1, B2, B, C, C1, C2;
	 double lambda = log(theta);

	 C1 = gsl_sf_log_erfc(-(z + d)/(sqrt(2.)*sigma));
	 C2 = exp(C1);
	 C   = 0.5 * C2;


     A1 = (lambda/2.) * (2. * (z + d) + sigma * sigma * lambda);
     A2 = gsl_sf_log_erfc(-(d + z + sigma * sigma * lambda) / (sigma * sqrt(2.)));
	 A  = -exp(A1 + A2)/4.0;

	 B1 = (lambda/2.0) * (-2.*(z+d) + sigma * sigma * lambda);
	 B2 = gsl_sf_log_erfc((d + z - sigma * sigma * lambda)/ (sigma*sqrt(2.)) );
	 B     = exp(B1 + B2)/4.0;
	 res = C + A + B;

     return res;
}

#if 0
void tsgd_gauss_pmf(double theta,double d,double sigma,info::Counts& pmf, double min_prob, bool accu_tails)
{
  double A1, A2, A, B1, B2, B, C3, C1, C2;
  // these do not depend on z
  double K0 = log(theta);
  double K1 =1.0/(sqrt(2.0)*sigma);
  double K2 = sigma*sigma*K0;

  std::fill(pmf.begin(),pmf.end(),min_prob);
  // negative side of PMF: eval in -z
  // f0 is TG(z-0.5), f1 is TG(z+0.5)
  // but for the valua at amin (and amax) the symbol accumulates the tail
  // so f0 starts with 1 (the end of the positive tail)
//  std::cout << "pmf.size()" << pmf.size() << std::endl;
  int offset = (int) floor(d);
  d = d - (double) offset;
  register int i;
  double f0=0,f1=0;
  double w;
  register double z = 0.5;
  w = z+d;
    // these do depend on z
  C1 = gsl_sf_log_erfc(-w*K1);
  C2 = exp(C1);
  C3   = 0.5 * C2;

  A1 = (K0/2.) * (2. * w + K2);
  A2 = gsl_sf_log_erfc(-(w + K2) * K1);
  A  = -exp(A1 + A2)/4.0;

  B1 = (K0/2.0) * (-2.*w + K2);
  B2 = gsl_sf_log_erfc((w - K2) * K1 );
  B     = exp(B1 + B2)/4.0;
  f0 = C3 + A + B;
  z -= 1.0;
  for (i=offset; i >= 0 ; z -=1.0 , i--)
  {
    w = z+d;
    C1 = gsl_sf_log_erfc(-w*K1);
    C2 = exp(C1);
    C3   = 0.5 * C2;

    A1 = (K0/2.) * (2. * w + K2);
    A2 = gsl_sf_log_erfc(-(w + K2) * K1);
    A  = -exp(A1 + A2)/4.0;

    B1 = (K0/2.0) * (-2.*w + K2);
    B2 = gsl_sf_log_erfc((w- K2) * K1 );
    B     = exp(B1 + B2)/4.0;
    f1 = C3 + A + B;
    pmf[i]=f0-f1;
    f0 = f1;
    if (pmf[i] < min_prob) break;
  }
  if ((i<0) && accu_tails)
  {
    pmf[0] += f1; // add continuous dist. tail to last value
  }
  i=offset;
  z=0.5;
  //
  // positive side:
  // first value is wrong
    w = -(z-1.0)-d;
    // these do depend on z
    C1 = gsl_sf_log_erfc(-w*K1);
    C2 = exp(C1);
    C3   = 0.5 * C2;

    A1 = (K0/2.) * (2. * w + K2);
    A2 = gsl_sf_log_erfc(-(w + K2) * K1);
    A  = -exp(A1 + A2)/4.0;

    B1 = (K0/2.0) * (-2.*w + K2);
    B2 = gsl_sf_log_erfc((w - K2) * K1 );
    B     = exp(B1 + B2)/4.0;
    f0 = C3 + A + B;

   for (; i < pmf.size(); z +=1.0, i++) {
    w = -z-d;
    // these do depend on z
    C1 = gsl_sf_log_erfc(-w*K1);
    C2 = exp(C1);
    C3   = 0.5 * C2;

    A1 = (K0/2.) * (2. * w + K2);
    A2 = gsl_sf_log_erfc(-(w + K2) * K1);
    A  = -exp(A1 + A2)/4.0;

    B1 = (K0/2.0) * (-2.*w + K2);
    B2 = gsl_sf_log_erfc((w - K2) * K1 );
    B     = exp(B1 + B2)/4.0;
    f1 = C3 + A + B;
    pmf[i]=f0-f1;
    if (pmf[i] < min_prob)
      break;
    f0 = f1;
  }
  if ((i==pmf.size()) && accu_tails)
  {
    pmf[i-1] += f1; // add continuous dist. tail to last value
  }
  // value at amax takes full tail starting from amax-0.5.
  // After loop this is in f0
  //std::cout << "i=" << i << " z=" << z << " f0=" << f0 << " f1=" << f1 << std::endl;
  // pmf[i] = f1; // this is to accumulate tails

}
#endif

// probability distribution for discrete TSGD+Gauss
double tsgd_gauss_discrete(int z, double theta, double d, double sigma)
{
	double res;
	if ( z <= 0 ) {
		res = tsgd_gauss_cumul(z+0.5, theta, d, sigma) -
		      tsgd_gauss_cumul(z-0.5, theta, d, sigma);
	} else {
		res = tsgd_gauss_discrete(-z, theta, -d, sigma);
        }


	return res;
}

#ifdef STANDALONE
int main(int argv, char *argv[])
{
//	double theta = 0.7, d=0.3, sigma=20.0;
	double theta = 0.7, d=0.9, sigma=1.0;
	int x;
  if (argc > 1) {
    theta = strtod(argv[1],NULL);
  }
  if (argc > 2) {
    d = strtod(argv[2],NULL);
  }
  if (argc > 3) {
    sigma = strtod(argv[3],NULL);
  }
  // std::cout << "theta=" << theta << " d=" << d << " sigma=" << s << std::endl;
	for ( x=-255; x<256; x++ ) {
		double p = tsgd_gauss_discrete(x, theta, d, sigma);
		double c = tsgd_gauss_cumul(x,theta,d,sigma);
		double pp = TSGD_Gauss_P(x,theta,d,sigma);
		cout << setw(5) << x << " "
		     << setw(14) << c << " " << setw(14) << p << setw(14) << pp << setw(12) << (pp-p)/p << endl;
	}
	return 0;
}

#endif // STANDALONE






